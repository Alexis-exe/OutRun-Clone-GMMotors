<!DOCTYPE html>

<html>

<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="lib/keyboard/keyboard.css">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <title>Javascript Racer - v4 (final)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link href="common.css" rel="stylesheet" type="text/css" />
  <style>
    /* Estilos para o canvas de contagem (largada) */
    #countdownCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 5;
      /* Fica acima do canvas principal */
      pointer-events: none;
      /* Permite que cliques passem para o jogo, se necess√°rio */

    }

    * {
      font-family: "Press Start 2P", serif;
      font-style: normal;
    }
  </style>
</head>

<body>
  <table id="controls" hidden>

    <tr>
      <td id="fps" colspan="2" hidden display="none"></td>
    </tr>
  </table>
  </div>
  <div id="lives" style="position: fixed; top: 10px; right: 10px; z-index: 10000;"></div>

  <div id="racer">
    <div id="hud">
      <span id="speed" class="hud"><span id="speed_value" class="value">0</span> mph</span>
      <span id="current_lap_time" class="hud">Time: <span id="current_lap_time_value" class="value">0.0</span></span>
      <span id="last_lap_time" class="hud">Last Lap: <span id="last_lap_time_value" class="value">0.0</span></span>
      <span id="fast_lap_time" class="hud">Fastest Lap: <span id="fast_lap_time_value" class="value">0.0</span></span>
    </div>

    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>

    <canvas id="countdownCanvas" width="1920" height="1080"></canvas>
    Loading...
  </div>

  <audio id='music'>
    <source src="music/racer.ogg">
    <source src="music/racer.mp3">
  </audio>
  <span id="mute"></span>

  <script src="stats.js"></script>
  <script src="common.js"></script>
  <script src="lib/jquery/3.6.1/jquery-3.6.1.min.js"></script>
  <script src="lib/keyboard/keyboard.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("fast_lap_time").style.display = "none";
    });
  </script>

  <script>

    var fps = 60;                      // how many 'update' frames per second
    var step = 1 / fps;                   // how long is each frame (in seconds)
    var width = 1920;                    // logical canvas width
    var height = 1080;                     // logical canvas height
    var centrifugal = 0.3;                     // centrifugal force multiplier when going around curves
    var offRoadDecel = 0.99;                    // speed multiplier when off road (e.g. you lose 2% speed each update frame)
    var skySpeed = 0.001;                   // background sky layer scroll speed when going around curve (or up hill)
    var hillSpeed = 0.002;                   // background hill layer scroll speed when going around curve (or up hill)
    var treeSpeed = 0.003;                   // background tree layer scroll speed when going around curve (or up hill)
    var skyOffset = 0;                       // current sky scroll offset
    var hillOffset = 0;                       // current hill scroll offset
    var treeOffset = 0;                       // current tree scroll offset
    var segments = [];                      // array of road segments
    var cars = [];                      // array of cars on the road
    var stats = Game.stats('fps');       // mr.doobs FPS counter
    var canvas = Dom.get('canvas');       // our canvas...
    var ctx = canvas.getContext('2d'); // ...and its drawing context
    var background = null;                    // our background image (loaded below)
    var sprites = null;                    // our spritesheet (loaded below)
    var resolution = null;                    // scaling factor to provide resolution independence (computed)
    var roadWidth = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
    var segmentLength = 200;                     // length of a single segment
    var rumbleLength = 3;                       // number of segments per red/white rumble strip
    var trackLength = null;                    // z length of entire track (computed)
    var lanes = 3;                       // number of lanes
    var fieldOfView = 100;                     // angle (degrees) for field of view
    var cameraHeight = 1000;                    // z height of camera
    var cameraDepth = null;                    // z distance camera is from screen (computed)
    var drawDistance = 300;                     // number of segments to draw
    var playerX = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
    var playerZ = null;                    // player relative z distance from camera (computed)
    var fogDensity = 5;                       // exponential fog density
    var position = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
    var speed = 0;                       // current speed
    var maxSpeed = segmentLength / step;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)
    var accel = maxSpeed / 5;             // acceleration rate - tuned until it 'felt' right
    var breaking = -maxSpeed;               // deceleration rate when braking
    var decel = -maxSpeed / 5;             // 'natural' deceleration rate when neither accelerating, nor braking
    var offRoadDecel = -maxSpeed / 2;             // off road deceleration is somewhere in between
    var offRoadLimit = maxSpeed / 4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)
    var totalCars = 200;                     // total number of cars on the road
    var currentLapTime = 0;                       // current lap time
    var lastLapTime = null;                    // last lap time

    var keyLeft = false;
    var keyRight = false;
    var keyFaster = false;
    var keySlower = false;

    var hud = {
      speed: { value: null, dom: Dom.get('speed_value') },
      current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },
      last_lap_time: { value: null, dom: Dom.get('last_lap_time_value') },
      fast_lap_time: { value: null, dom: Dom.get('fast_lap_time_value') }
    }

    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

    function update(dt) {

      if (gameOverState) {
        speed = 0;
        return;
      }

      var n, car, carW, sprite, spriteW;
      var playerSegment = findSegment(position + playerZ);
      var playerW = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;
      var speedPercent = speed / maxSpeed;
      var dx = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
      var startPosition = position;

      updateCars(dt, playerSegment, playerW);

      position = Util.increase(position, dt * speed, trackLength);

      if (keyLeft)
        playerX = playerX - dx;
      else if (keyRight)
        playerX = playerX + dx;

      playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);

      if (keyFaster)
        speed = Util.accelerate(speed, accel, dt);
      else if (keySlower)
        speed = Util.accelerate(speed, breaking, dt);
      else
        speed = Util.accelerate(speed, decel, dt);


      if ((playerX < -1) || (playerX > 1)) {

        if (speed > offRoadLimit)
          speed = Util.accelerate(speed, offRoadDecel, dt);

        for (n = 0; n < playerSegment.sprites.length; n++) {
          sprite = playerSegment.sprites[n];
          spriteW = sprite.source.w * SPRITES.SCALE;
          if (Util.overlap(playerX, playerW, sprite.offset + spriteW / 2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {
            speed = maxSpeed / 5;
            position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite (at front of segment)
            break;
          }
        }
      }

      for (n = 0; n < playerSegment.cars.length; n++) {
        car = playerSegment.cars[n];
        carW = car.sprite.w * SPRITES.SCALE;
        if (speed > car.speed) {
          if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
            speed = car.speed * (car.speed / speed);
            position = Util.increase(car.z, -playerZ, trackLength);
            break;
          }
        }
      }

      playerX = Util.limit(playerX, -3, 3);     // dont ever let it go too far out of bounds
      speed = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed

      skyOffset = Util.increase(skyOffset, skySpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
      hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
      treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);

      if (position > playerZ) {
        if (currentLapTime && (startPosition < playerZ)) {
          lastLapTime = currentLapTime;
          currentLapTime = 0;
          if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {
            Dom.storage.fast_lap_time = lastLapTime;
            updateHud('fast_lap_time', formatTime(lastLapTime));
            Dom.addClassName('fast_lap_time', 'fastest');
            Dom.addClassName('last_lap_time', 'fastest');
          }
          else {
            Dom.removeClassName('fast_lap_time', 'fastest');
            Dom.removeClassName('last_lap_time', 'fastest');
          }
          updateHud('last_lap_time', formatTime(lastLapTime));
          Dom.show('last_lap_time');
        }
        else {
          currentLapTime += dt;
        }
      }

      updateHud('speed', 5 * Math.round(speed / 500));
      updateHud('current_lap_time', formatTime(currentLapTime));

      verificaColisao();
    }

    //-------------------------------------------------------------------------

    function updateCars(dt, playerSegment, playerW) {
      var n, car, oldSegment, newSegment;
      for (n = 0; n < cars.length; n++) {
        car = cars[n];
        oldSegment = findSegment(car.z);
        car.offset = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);
        car.z = Util.increase(car.z, dt * car.speed, trackLength);
        car.percent = Util.percentRemaining(car.z, segmentLength); // useful for interpolation during rendering phase
        newSegment = findSegment(car.z);
        if (oldSegment != newSegment) {
          index = oldSegment.cars.indexOf(car);
          oldSegment.cars.splice(index, 1);
          newSegment.cars.push(car);
        }
      }
    }

    function updateCarOffset(car, carSegment, playerSegment, playerW) {

      var i, j, dir, segment, otherCar, otherCarW, lookahead = 20, carW = car.sprite.w * SPRITES.SCALE;

      // optimization, dont bother steering around other cars when 'out of sight' of the player
      if ((carSegment.index - playerSegment.index) > drawDistance)
        return 0;

      for (i = 1; i < lookahead; i++) {
        segment = segments[(carSegment.index + i) % segments.length];

        if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {
          if (playerX > 0.5)
            dir = -1;
          else if (playerX < -0.5)
            dir = 1;
          else
            dir = (car.offset > playerX) ? 1 : -1;
          return dir * 1 / i * (car.speed - speed) / maxSpeed; // the closer the cars (smaller i) and the greated the speed ratio, the larger the offset
        }

        for (j = 0; j < segment.cars.length; j++) {
          otherCar = segment.cars[j];
          otherCarW = otherCar.sprite.w * SPRITES.SCALE;
          if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {
            if (otherCar.offset > 0.5)
              dir = -1;
            else if (otherCar.offset < -0.5)
              dir = 1;
            else
              dir = (car.offset > otherCar.offset) ? 1 : -1;
            return dir * 1 / i * (car.speed - otherCar.speed) / maxSpeed;
          }
        }
      }

      // if no cars ahead, but I have somehow ended up off road, then steer back on
      if (car.offset < -0.9)
        return 0.1;
      else if (car.offset > 0.9)
        return -0.1;
      else
        return 0;
    }

    //-------------------------------------------------------------------------

    function updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed
      if (hud[key].value !== value) {
        hud[key].value = value;
        Dom.set(hud[key].dom, value);
      }
    }

    function formatTime(dt) {
      var minutes = Math.floor(dt / 60);
      var seconds = Math.floor(dt % 60);
      var hundredths = Math.floor((dt - Math.floor(dt)) * 100);

      // Sempre exibe minutos, mesmo que seja 0, e garante que os segundos tenham 2 d√≠gitos
      return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + (hundredths < 10 ? "0" : "") + hundredths;
    }



    //=========================================================================
    // RENDER THE GAME WORLD
    //=========================================================================

    function render() {

      var baseSegment = findSegment(position);
      var basePercent = Util.percentRemaining(position, segmentLength);
      var playerSegment = findSegment(position + playerZ);
      var playerPercent = Util.percentRemaining(position + playerZ, segmentLength);
      var playerY = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
      var maxy = height;

      var x = 0;
      var dx = - (baseSegment.curve * basePercent);

      ctx.clearRect(0, 0, width, height);

      Render.background(ctx, background, width, height, BACKGROUND.SKY, skyOffset, resolution * skySpeed * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);

      var n, i, segment, car, sprite, spriteScale, spriteX, spriteY;

      for (n = 0; n < drawDistance; n++) {

        segment = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog = Util.exponentialFog(n / drawDistance, fogDensity);
        segment.clip = maxy;

        Util.project(segment.p1, (playerX * roadWidth) - x, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

        x = x + dx;
        dx = dx + segment.curve;

        if ((segment.p1.camera.z <= cameraDepth) || // behind us
          (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
          (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill
          continue;

        Render.segment(ctx, width, lanes,
          segment.p1.screen.x,
          segment.p1.screen.y,
          segment.p1.screen.w,
          segment.p2.screen.x,
          segment.p2.screen.y,
          segment.p2.screen.w,
          segment.fog,
          segment.color);

        maxy = segment.p1.screen.y;
      }

      for (n = (drawDistance - 1); n > 0; n--) {
        segment = segments[(baseSegment.index + n) % segments.length];

        for (i = 0; i < segment.cars.length; i++) {
          car = segment.cars[i];
          sprite = car.sprite;
          spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
          spriteX = Util.interpolate(segment.p1.screen.x, segment.p2.screen.x, car.percent) + (spriteScale * car.offset * roadWidth * width / 2);
          spriteY = Util.interpolate(segment.p1.screen.y, segment.p2.screen.y, car.percent);
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
        }

        for (i = 0; i < segment.sprites.length; i++) {
          sprite = segment.sprites[i];
          spriteScale = segment.p1.screen.scale;
          spriteX = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width / 2);
          spriteY = segment.p1.screen.y;
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), -1, segment.clip);
        }

        if (segment == playerSegment) {
          if (!isFlashing || (isFlashing && (Math.floor(Date.now() / 200) % 2 === 0))) {
            Render.player(
              ctx, width, height, resolution, roadWidth, sprites,
              speed / maxSpeed,
              cameraDepth / playerZ,
              width / 2,
              (height / 2) - (cameraDepth / playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height / 2),
              speed * (keyLeft ? -1 : keyRight ? 1 : 0),
              playerSegment.p2.world.y - playerSegment.p1.world.y
            );
          }
        }
      }
    }

    function findSegment(z) {
      return segments[Math.floor(z / segmentLength) % segments.length];
    }

    //=========================================================================
    // BUILD ROAD GEOMETRY
    //=========================================================================

    function lastY() { return (segments.length == 0) ? 0 : segments[segments.length - 1].p2.world.y; }

    function addSegment(curve, y) {
      var n = segments.length;
      segments.push({
        index: n,
        p1: { world: { y: lastY(), z: n * segmentLength }, camera: {}, screen: {} },
        p2: { world: { y: y, z: (n + 1) * segmentLength }, camera: {}, screen: {} },
        curve: curve,
        sprites: [],
        cars: [],
        color: Math.floor(n / rumbleLength) % 2 ? COLORS.DARK : COLORS.LIGHT
      });
    }

    function addSprite(n, sprite, offset) {
      segments[n].sprites.push({ source: sprite, offset: offset });
    }

    function addRoad(enter, hold, leave, curve, y) {
      var startY = lastY();
      var endY = startY + (Util.toInt(y, 0) * segmentLength);
      var n, total = enter + hold + leave;
      for (n = 0; n < enter; n++)
        addSegment(Util.easeIn(0, curve, n / enter), Util.easeInOut(startY, endY, n / total));
      for (n = 0; n < hold; n++)
        addSegment(curve, Util.easeInOut(startY, endY, (enter + n) / total));
      for (n = 0; n < leave; n++)
        addSegment(Util.easeInOut(curve, 0, n / leave), Util.easeInOut(startY, endY, (enter + hold + n) / total));
    }

    var ROAD = {
      LENGTH: { NONE: 0, SHORT: 25, MEDIUM: 50, LONG: 100 },
      HILL: { NONE: 0, LOW: 20, MEDIUM: 40, HIGH: 60 },
      CURVE: { NONE: 0, EASY: 2, MEDIUM: 4, HARD: 6 }
    };

    function addStraight(num) {
      num = num || ROAD.LENGTH.MEDIUM;
      addRoad(num, num, num, 0, 0);
    }

    function addHill(num, height) {
      num = num || ROAD.LENGTH.MEDIUM;
      height = height || ROAD.HILL.MEDIUM;
      addRoad(num, num, num, 0, height);
    }

    function addCurve(num, curve, height) {
      num = num || ROAD.LENGTH.MEDIUM;
      curve = curve || ROAD.CURVE.MEDIUM;
      height = height || ROAD.HILL.NONE;
      addRoad(num, num, num, curve, height);
    }

    function addLowRollingHills(num, height) {
      num = num || ROAD.LENGTH.SHORT;
      height = height || ROAD.HILL.LOW;
      addRoad(num, num, num, 0, height / 2);
      addRoad(num, num, num, 0, -height);
      addRoad(num, num, num, ROAD.CURVE.EASY, height);
      addRoad(num, num, num, 0, 0);
      addRoad(num, num, num, -ROAD.CURVE.EASY, height / 2);
      addRoad(num, num, num, 0, 0);
    }

    function addSCurves() {
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.NONE);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.EASY, -ROAD.HILL.LOW);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);
    }

    function addBumps() {
      addRoad(10, 10, 10, 0, 5);
      addRoad(10, 10, 10, 0, -2);
      addRoad(10, 10, 10, 0, -5);
      addRoad(10, 10, 10, 0, 8);
      addRoad(10, 10, 10, 0, 5);
      addRoad(10, 10, 10, 0, -7);
      addRoad(10, 10, 10, 0, 5);
      addRoad(10, 10, 10, 0, -2);
    }

    function addDownhillToEnd(num) {
      num = num || 200;
      addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY() / segmentLength);
    }

    function resetRoad() {
      segments = [];

      addStraight(ROAD.LENGTH.SHORT);
      addLowRollingHills();
      addSCurves();
      addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
      addBumps();
      addLowRollingHills();
      addCurve(ROAD.LENGTH.LONG * 2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
      addStraight();
      addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
      addSCurves();
      addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);
      addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);
      addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
      addBumps();
      addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);
      addStraight();
      addSCurves();
      addDownhillToEnd();

      resetSprites();
      resetCars();

      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[findSegment(playerZ).index + 3].color = COLORS.START;
      for (var n = 0; n < rumbleLength; n++)
        segments[segments.length - 1 - n].color = COLORS.FINISH;

      trackLength = segments.length * segmentLength;
    }

    function resetSprites() {
      var n, i;

      addSprite(20, SPRITES.BILLBOARD07, -1);
      addSprite(40, SPRITES.BILLBOARD06, -1);
      addSprite(60, SPRITES.BILLBOARD08, -1);
      addSprite(80, SPRITES.BILLBOARD09, -1);
      addSprite(100, SPRITES.BILLBOARD01, -1);
      addSprite(120, SPRITES.BILLBOARD02, -1);
      addSprite(140, SPRITES.BILLBOARD03, -1);
      addSprite(160, SPRITES.BILLBOARD04, -1);
      addSprite(180, SPRITES.BILLBOARD05, -1);

      addSprite(240, SPRITES.BILLBOARD07, -1.2);
      addSprite(240, SPRITES.BILLBOARD06, 1.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD07, -1.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD06, 1.2);

      for (n = 10; n < 200; n += 4 + Math.floor(n / 100)) {
        addSprite(n, SPRITES.PALM_TREE, 0.5 + Math.random() * 0.5);
        addSprite(n, SPRITES.PALM_TREE, 1 + Math.random() * 2);
      }

      for (n = 250; n < 1000; n += 5) {
        addSprite(n, SPRITES.COLUMN, 1.1);
        addSprite(n + Util.randomInt(0, 5), SPRITES.TREE1, -1 - (Math.random() * 2));
        addSprite(n + Util.randomInt(0, 5), SPRITES.TREE2, -1 - (Math.random() * 2));
      }

      for (n = 200; n < segments.length; n += 3) {
        addSprite(n, Util.randomChoice(SPRITES.PLANTS), Util.randomChoice([1, -1]) * (2 + Math.random() * 5));
      }

      var side, sprite, offset;
      for (n = 1000; n < (segments.length - 50); n += 100) {
        side = Util.randomChoice([1, -1]);
        addSprite(n + Util.randomInt(0, 50), Util.randomChoice(SPRITES.BILLBOARDS), -side);
        for (i = 0; i < 20; i++) {
          sprite = Util.randomChoice(SPRITES.PLANTS);
          offset = side * (1.5 + Math.random());
          addSprite(n + Util.randomInt(0, 50), sprite, offset);
        }

      }

    }

    function resetCars() {
      cars = [];
      var n, car, segment, offset, z, sprite, speed;
      for (var n = 0; n < totalCars; n++) {
        offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
        z = Math.floor(Math.random() * segments.length) * segmentLength;
        sprite = Util.randomChoice(SPRITES.CARS);
        speed = maxSpeed / 4 + Math.random() * maxSpeed / (sprite == SPRITES.SEMI ? 4 : 2);
        car = { offset: offset, z: z, sprite: sprite, speed: speed };
        segment = findSegment(car.z);
        segment.cars.push(car);
        cars.push(car);
      }
    }

    //=========================================================================
    // THE GAME LOOP
    //=========================================================================

    Game.run({
      canvas: canvas, render: render, update: update, stats: stats, step: step,
      images: ["background", "sprites"],
      keys: [
        { keys: [KEY.LEFT, KEY.A], mode: 'down', action: function () { keyLeft = true; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function () { keyRight = true; } },
        { keys: [KEY.UP, KEY.W], mode: 'down', action: function () { keyFaster = true; } },
        { keys: [KEY.DOWN, KEY.S], mode: 'down', action: function () { keySlower = true; } },
        { keys: [KEY.LEFT, KEY.A], mode: 'up', action: function () { keyLeft = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up', action: function () { keyRight = false; } },
        { keys: [KEY.UP, KEY.W], mode: 'up', action: function () { keyFaster = false; } },
        { keys: [KEY.DOWN, KEY.S], mode: 'up', action: function () { keySlower = false; } }
      ],
      ready: function (images) {
        background = images[0];
        sprites = images[1];
        reset();
        Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
        updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));
        updateLivesHUD();
      }
    });

    function reset(options) {
      options = options || {};
      canvas.width = width = Util.toInt(options.width, width);
      canvas.height = height = Util.toInt(options.height, height);
      lanes = Util.toInt(options.lanes, lanes);
      roadWidth = Util.toInt(options.roadWidth, roadWidth);
      cameraHeight = Util.toInt(options.cameraHeight, cameraHeight);
      drawDistance = Util.toInt(options.drawDistance, drawDistance);
      fogDensity = Util.toInt(options.fogDensity, fogDensity);
      fieldOfView = Util.toInt(options.fieldOfView, fieldOfView);
      segmentLength = Util.toInt(options.segmentLength, segmentLength);
      rumbleLength = Util.toInt(options.rumbleLength, rumbleLength);
      cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);
      playerZ = (cameraHeight * cameraDepth);
      resolution = height / width;
      refreshTweakUI();

      if ((segments.length == 0) || (options.segmentLength) || (options.rumbleLength))
        resetRoad(); // only rebuild road when necessary
    }

    //=========================================================================
    // TWEAK UI HANDLERS
    //=========================================================================


    function refreshTweakUI() {

    }

    function updateLivesHUD() {
      var livesContainer = document.getElementById('lives');
      // Limpa o conte√∫do atual
      livesContainer.innerHTML = '';
      // Para cada vida restante, cria um elemento <img> com o √≠cone do cora√ß√£o
      for (var i = 0; i < lives; i++) {
        var img = document.createElement('img');
        img.src = 'images/life.png'; // substitua pelo caminho da sua imagem de cora√ß√£o
        img.style.width = '130px';    // ajuste o tamanho conforme necess√°rio
        img.style.height = '130px';
        img.style.marginLeft = '5px';
        livesContainer.appendChild(img);
      }
    }


    // Vari√°vel de controle para permitir o log da colis√£o
    // Flag para permitir o log de colis√£o apenas uma vez a cada 3 segundos
    var podeLogarColisao = true;
    // Flag para indicar que o carro deve piscar (flash)
    var isFlashing = false;

    var maxLives = 3;   // Quantidade total de cora√ß√µes/vidas
    var lives = maxLives; // Vidas atuais

    function verificaColisao() {
      if (gameOverState) return false; // Se j√° estiver game over, n√£o processa colis√µes
      var playerSegment = findSegment(position + playerZ);
      var playerW = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;

      // Verifica se o jogador est√° fora dos limites da pista
      if (playerX < -1 || playerX > 1) {
        for (var i = 0; i < playerSegment.sprites.length; i++) {
          var sprite = playerSegment.sprites[i];
          var spriteW = sprite.source.w * SPRITES.SCALE;
          var spritePos = sprite.offset + (spriteW / 2) * (sprite.offset > 0 ? 1 : -1);
          if (Util.overlap(playerX, playerW, spritePos, spriteW)) {
            if (podeLogarColisao) {
              collisionCount++;
              lives = maxLives - collisionCount;
              updateLivesHUD();
              // Se n√£o houver mais vidas, termina o jogo
              if (lives <= 0) {
                gameOverState = true;
                gameOver();
                return true;
              }
              console.log("bateu fora");
              podeLogarColisao = false;
              isFlashing = true;
              setTimeout(function () {
                podeLogarColisao = true;
                isFlashing = false;
              }, 3000);
            }
            // Reposiciona o jogador no centro e reduz a velocidade
            playerX = 0;
            speed = maxSpeed / 5;
            return true;
          }
        }
      }

      // Verifica colis√£o com outros carros
      for (var i = 0; i < playerSegment.cars.length; i++) {
        var car = playerSegment.cars[i];
        var carW = car.sprite.w * SPRITES.SCALE;
        if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
          if (podeLogarColisao && raceStarted) {
            collisionCount++;
            lives = maxLives - collisionCount;
            updateLivesHUD();
            if (lives <= 0) {
              gameOverState = true;
              gameOver();
              return true;
            }
            console.log("bateu");
            podeLogarColisao = false;
            isFlashing = true;
            setTimeout(function () {
              podeLogarColisao = true;
              isFlashing = false;
            }, 3000);
          }
          // Reduz a velocidade em caso de colis√£o
          speed = maxSpeed / 5;
          return true;
        }
      }
      return false;
    }


    var collisionCount = 0;
    var gameOverState = false;

    window.addEventListener("load", function () {
      Keyboard.init();
    });

    document.addEventListener("click", function (event) {
      // Seleciona o elemento do teclado e o input
      var keyboardElement = document.querySelector('.keyboard');
      var inputElement = document.querySelector('.use-keyboard-input');

      // Se algum dos elementos n√£o existir, n√£o faz nada
      if (!keyboardElement || !inputElement) return;

      // Se o clique N√ÉO for dentro do teclado E nem dentro do input, fecha o teclado
      if (!keyboardElement.contains(event.target) && !inputElement.contains(event.target)) {
        // Se a biblioteca possuir um m√©todo para fechar o teclado, use-o:
        if (typeof Keyboard.close === 'function') {
          Keyboard.close();
        } else {
          // Caso contr√°rio, adicione uma classe para ocult√°-lo (assegure-se de ter a classe .keyboard--hidden definida no CSS)
          keyboardElement.classList.add('keyboard--hidden');
        }
      }
    });

    function gameOver() {
      console.log(formatTime(currentLapTime));
      console.log(timeGame);

      // Adiciona a fonte "Press Start 2P"
      var link = document.createElement("link");
      link.rel = "stylesheet";
      document.head.appendChild(link);

      // Cria um overlay que cobre toda a tela
      var overlay = document.createElement("div");
      overlay.id = "gameover-overlay";
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
      overlay.style.display = "flex";
      overlay.style.flexDirection = "column";
      overlay.style.alignItems = "center";
      overlay.style.justifyContent = "center";
      overlay.style.textAlign = "center"; // Centraliza o conte√∫do
      overlay.style.zIndex = 29;

      // Cria a mensagem "Game Over"
      var message = document.createElement("h1");
      message.innerText = "Game Over";
      message.style.color = "#FFF";
      message.style.fontSize = "64px";
      message.style.marginBottom = "40px";
      overlay.appendChild(message);

      // Cria um container para o input e a exibi√ß√£o do tempo
      var inputContainer = document.createElement("div");
      inputContainer.style.display = "inline-flex"; // Posiciona lado a lado
      inputContainer.style.alignItems = "center";
      inputContainer.style.gap = "10px"; // Espa√ßo entre os elementos
      inputContainer.style.marginBottom = "20px";

      // Cria o input para digitar o nome
      // Cria o input para digitar o nome
      var nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = "Digite seu nome";
      nameInput.style.padding = "10px";
      nameInput.style.fontSize = "20px";
      nameInput.style.textAlign = "center";
      nameInput.maxLength = 10;
      // Adiciona a classe para manter a consist√™ncia (opcional)
      nameInput.classList.add("use-keyboard-input");

      // Adiciona manualmente o event listener de foco
      nameInput.addEventListener("focus", function () {
        // Se necess√°rio, desliga o CapsLock inicialmente
        Keyboard._toggleCapsLock(false);
        // Abre o teclado, passando o valor atual e uma fun√ß√£o callback que atualiza o input
        Keyboard.open(nameInput.value, function (currentValue, el) {
          nameInput.value = currentValue;
        });
      });

      inputContainer.appendChild(nameInput);

      // Cria o elemento para exibir o tempo, com o r√≥tulo "Tempo conseguido:"
      var timeDisplay = document.createElement("div");
      timeDisplay.innerText = "Tempo: " + formatTime(currentLapTime);
      timeDisplay.style.border = "2px solid #FFF";
      timeDisplay.style.borderRadius = "8px";
      timeDisplay.style.padding = "5px 10px";
      timeDisplay.style.fontSize = "20px";
      timeDisplay.style.color = "#FFF";
      inputContainer.appendChild(timeDisplay);

      // Adiciona o container ao overlay
      overlay.appendChild(inputContainer);

      // Cria o bot√£o de confirmar
      var confirmButton = document.createElement("button");
      confirmButton.innerText = "Confirmar";
      confirmButton.style.padding = "10px 20px";
      confirmButton.style.fontSize = "20px";
      confirmButton.style.cursor = "pointer";
      confirmButton.style.border = "none";
      confirmButton.style.backgroundColor = "#FFF";
      confirmButton.style.color = "#000";
      confirmButton.style.transition = "background-color 0.2s ease"; // Anima√ß√£o de transi√ß√£o
      overlay.appendChild(confirmButton);

      // Fun√ß√£o para adicionar efeito de clique (escurece a cor) aos bot√µes para mouse e touch
      function addButtonPressEffect(button) {
        const originalColor = "#FFF";
        const darkColor = "#ccc";

        // Eventos para mouse
        button.addEventListener("mousedown", function () {
          button.style.backgroundColor = darkColor;
        });
        button.addEventListener("mouseup", function () {
          button.style.backgroundColor = originalColor;
        });
        button.addEventListener("mouseleave", function () {
          button.style.backgroundColor = originalColor;
        });
        // Eventos para toque (touch)
        button.addEventListener("touchstart", function () {
          button.style.backgroundColor = darkColor;
        });
        button.addEventListener("touchend", function () {
          button.style.backgroundColor = originalColor;
        });
        button.addEventListener("touchcancel", function () {
          button.style.backgroundColor = originalColor;
        });
      }

      addButtonPressEffect(confirmButton);

      // Vari√°vel para armazenar o nome do jogador (caso precise utiliz√°-lo em outros contextos)
      var playerName = "";

      // Ao clicar no bot√£o de confirmar:
      confirmButton.addEventListener("click", function () {
        if (typeof Keyboard.close === 'function') {
          Keyboard.close();
        }

        playerName = nameInput.value;
        nameInput.classList.add("use-keyboard-input");
        confirmButton.style.zIndex = 9999;
        nameInput.style.zIndex = 30;

        console.log("Nome do jogador:", playerName);

        const saveUrl = `/saveData?nome=${encodeURIComponent(playerName)}&tempo=${encodeURIComponent(currentLapTime)}`;
        fetch(saveUrl)
          .then(response => response.json())
          .then(data => {
            console.log("Dados salvos:", data);
            return fetch("/dados");
          })
          .then(response => response.json())
          .then(top10Data => {
            // Remove elementos de input
            overlay.removeChild(inputContainer);
            overlay.removeChild(confirmButton);

            // Cria t√≠tulo do ranking
            var rankTitle = document.createElement("h2");
            rankTitle.innerText = "- Rank - ";
            rankTitle.style.color = "#FFF";
            rankTitle.style.fontSize = "32px";
            rankTitle.style.marginBottom = "10px";
            overlay.appendChild(rankTitle);

            // Cria estrutura da tabela
            var table = document.createElement("table");
            table.style.marginTop = "20px";
            table.style.borderCollapse = "collapse";
            table.style.color = "#FFF";

            // Cabe√ßalho da tabela
            var thead = document.createElement("thead");
            var headerRow = document.createElement("tr");

            var thPos = document.createElement("th");
            thPos.innerText = "#";
            thPos.style.border = "2px solid #FFF";
            thPos.style.padding = "10px";

            var thNome = document.createElement("th");
            thNome.innerText = "Nome";
            thNome.style.border = "2px solid #FFF";
            thNome.style.padding = "10px";

            var thTempo = document.createElement("th");
            thTempo.innerText = "Tempo";
            thTempo.style.border = "2px solid #FFF";
            thTempo.style.padding = "10px";

            headerRow.appendChild(thPos);
            headerRow.appendChild(thNome);
            headerRow.appendChild(thTempo);
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Corpo da tabela com dados din√¢micos
            var tbody = document.createElement("tbody");
            for (var i = 1; i <= 10; i++) {
              var row = document.createElement("tr");
              const dataIndex = i - 1;
              const entry = top10Data[dataIndex];

              // Coluna de Posi√ß√£o
              var tdPos = document.createElement("td");
              tdPos.innerText = i + "¬∞";
              tdPos.style.border = "2px solid #FFF";
              tdPos.style.padding = "10px";
              row.appendChild(tdPos);

              // Coluna de Nome
              var tdNome = document.createElement("td");
              tdNome.innerText = entry ? entry.nome : "-";
              tdNome.style.border = "2px solid #FFF";
              tdNome.style.padding = "10px";
              row.appendChild(tdNome);

              // Coluna de Tempo
              var tdTempo = document.createElement("td");
              // Converte a string para n√∫mero e formata o tempo
              tdTempo.innerText = entry ? formatTime(parseFloat(entry.tempo)) : "-";
              tdTempo.style.border = "2px solid #FFF";
              tdTempo.style.padding = "10px";
              row.appendChild(tdTempo);


              tbody.appendChild(row);
            }
            table.appendChild(tbody);
            overlay.appendChild(table);

            // Bot√£o Jogar Novamente
            var playAgainButton = document.createElement("button");
            playAgainButton.innerText = "Jogar Novamente";
            playAgainButton.style.padding = "20px 40px";
            playAgainButton.style.fontSize = "32px";
            playAgainButton.style.cursor = "pointer";
            playAgainButton.style.border = "none";
            playAgainButton.style.backgroundColor = "#FFF";
            playAgainButton.style.color = "#000";
            playAgainButton.style.transition = "background-color 0.2s ease";
            playAgainButton.style.marginTop = "65px";
            overlay.appendChild(playAgainButton);

            addButtonPressEffect(playAgainButton);

            playAgainButton.addEventListener("click", function () {
              window.location.reload();
            });
          })
          .catch(error => console.error('Erro:', error));
      });

      // Adiciona o overlay ao body
      document.body.appendChild(overlay);
    }

    //=========================================================================

  </script>

</body>

</html>